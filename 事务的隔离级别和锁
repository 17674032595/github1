1. 事务的特性(ACID)：

(1) 原子性 Atomicity: 事务所包含的数据库操作要么都做，要么都不做

(2) 一致性 Consistency: 事务前后，所有的数据都保持一致的状态

例如：事务之前A，B两个账户的总和是10万(A: 4W, B: 6W), 现在A转账2W给B (A: 2W, B: 8W)

A, B账户总和依旧是10W，如果不是10W的话，则事务前后对于账户总和这种资源是不一致的。

(3) 隔离性 Isolation: 事务对数据的操作不能够受到其他事务的影响

(4) 持续性 Durability: 数据库事务一旦提交，其对数据库中数据的改变应该是永久性的



2. 事务的结束方式包括：

commit， rollback



3. 破坏事务ACID特性的因素包括：

(1) 多个事务并行运行，不同的操作交叉执行

(2) 事务在运行过程中被强行终止



4. 并发事务带来的问题：

数据库并发的事务会带来以下问题：

(1) 脏读：事务a修改数据时，事务b读取了该数据，但是事务a由于某种原因取消了对数据的修改，使数据返回了原状态，这时事务b读取的数据与数据库中的数据就会不一致。

(2) 不可重复读：事务a读取数据库中的数据后，事务b更新了该数据，当事务a再次读取该数据时，就会发现数据已经发生了改变

(3) 幻影读：事务a基于某个条件读取数据后，事务b在同一个表中插入了一条数据，这时事务a基于相同的条件再次读取数据时，返回了不同的行



5. 事务隔离级别

为了保证数据的一致性，一般采用了事务隔离机制，又称为事务串行化，用来保证事务尽量按照串行的方式执行

级别1：读取未提交，这种并发性最高，但会导致上述三个问题

级别2：读取已提交，这是oracle的默认隔离级别

级别3：可重复读

级别4：串行，这种隔离级别最高，但数据库并发会受到很大的限制，可以避免上述三个问题，但项目中不会采用

 

6. 数据库锁

数据库是一个多用户使用的共享资源，当多个用户并发地存取数据时，在数据库中就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性。

加锁是实现数据库并发控制的一个非常重要的技术，当事务在对某个数据对象进行操作前，先向系统发出请求，对其加锁，加锁后事务就对该数据对象有了一定的控制，在该事务释放锁之前，其他的事务不能对此数据对象进行更新操作。

两种锁机制：

共享锁(S锁)：加了共享锁的数据库对象可以被其他事务读取，但是不能被其他事务修改。

独占锁(X锁)：加了独占锁的数据库对象不能被其他事务读取和修改。

commit或rollback后，事务所使用的锁被释放。



7. 数据库锁的类型：

(1) DML锁(data locks 数据锁)：能够防止同步冲突的DML和DDL操作的破坏性，是oracle主要的锁，又包括表级锁(TM锁)和行级锁(TX锁)

当oracle执行DML语句的时候，系统自动在所要操作的表上申请TM类型的锁，当TM锁获得后，系统再自动申请TX类型的锁。

当多个会话在表的同一条记录上执行DML语句时，第一个会话在该条记录上加锁，其他的会话处于等待状态，当第一个会话提交后，TX锁会被释放，其他的会话才可以加锁。

当oracle数据库产生TX锁等待时，如果不及时处理常常会引起oracle数据库挂起或导致死锁的产生。




死锁：

当两个用户互相等待对方释放资源时，oracle认定为产生了死锁，将以牺牲一个用户作为代价，另一个用户继续执行，牺牲的用户的事务将回滚。

例子：

用户1对A表进行update，没有提交

用户2对B表进行update，没有提交

如果用户2此时对A表做update，则会发生阻塞，需要等待用户1的事务结束

如果此时用户1对B表做update，则产生死锁，此时oracle会选择其中一个用户进行回滚，使另一个用户继续执行操作。


(2) DDL锁(dictionary locks字典锁): 用于保护数据库对象的结构，如表、索引的结构定义



问题：既然有了锁，为什么还要隔离级别？

事务隔离级别是并发控制的整体解决方案，其实际上是综合利用各种类型的锁和行版本控制来解决并发问题。

锁是数据库并发控制的内部机制，是基础

对用户来说，只有当事务隔离级别无法解决一些并发问题和需求时，才有必要在语句中手动设置锁，不恰当的设置锁可能导致严重的阻塞和死锁。建议在完全了解锁机制的情况下，才可以再语句中手动设置锁，否则应该使用事务隔离级别。
